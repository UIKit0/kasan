AddressSanitizer
================


0. Overview
===========

AddressSanitizer (or ASAN) is a dynamic memory error detector. It provides fast
and comprehensive solution for use-after-free (UAF) and out-of-bounds (OOB)
bugs. Enabled with CONFIG_ASAN=y, currently works only on x86_64.

ASAN is better than all of CONFIG_DEBUG_PAGEALLOC/CONFIG_DEBUG_SLAB/
CONFIG_KMEMCHECK, because it:
 - is based on compiler instrumentation (fast),
 - detects OOB for both writes and reads,
 - provides strong UAF detection (based on delayed memory reuse),
 - does prompt detection of bad memory accesses,
 - prints informative reports.

More information is available at:
https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel

TODO: slowdown and additional memory usage.


1. Reports
==========

A typical report will look something like this:

=========================================================================
AddressSanitizer: heap-use-after-free on address ffff8800230ef384
Write of size 4 by thread T12887:
 [<ffffffff811046dc>] ____call_usermodehelper+0x20c/0x230
 [<ffffffff81104733>] call_helper+0x33/0x40
 [<ffffffff8184226c>] ret_from_fork+0x7c/0xb0

Freed by thread T12636:
 [<ffffffff8110424c>] call_usermodehelper_freeinfo+0x2c/0x30
 [<ffffffff811049d5>] call_usermodehelper_exec+0xa5/0x1c0
 [<ffffffff811052b0>] call_usermodehelper+0x40/0x60
 [<ffffffff8146c15e>] kobject_uevent_env+0x5ee/0x620
 [<ffffffff8146c19b>] kobject_uevent+0xb/0x10
 [<ffffffff8173bd7f>] net_rx_queue_update_kobjects+0xaf/0x150
 [<ffffffff8173c179>] netdev_register_kobject+0x139/0x1a0
 [<ffffffff8171f508>] register_netdevice+0x4d8/0x660
 [<ffffffff8171f6aa>] register_netdev+0x1a/0x30
 [<ffffffff81617d1a>] loopback_net_init+0x5a/0xd0
 [<ffffffff8170e64b>] ops_init+0x5b/0x1b0
 [<ffffffff8170e86b>] setup_net+0xcb/0x1f0
 [<ffffffff8170f1e8>] copy_net_ns+0x88/0x150
 [<ffffffff8111c537>] create_new_namespaces+0x1f7/0x2d0
 [<ffffffff8111c822>] unshare_nsproxy_namespaces+0x72/0xd0
 [<ffffffff810e10a1>] SyS_unshare+0x1c1/0x340

Allocated by thread T12636:
 [<ffffffff81104dfb>] call_usermodehelper_setup+0x5b/0x170
 [<ffffffff811052a1>] call_usermodehelper+0x31/0x60
 [<ffffffff8146c15e>] kobject_uevent_env+0x5ee/0x620
 [<ffffffff8146c19b>] kobject_uevent+0xb/0x10
 [<ffffffff8173bd7f>] net_rx_queue_update_kobjects+0xaf/0x150
 [<ffffffff8173c179>] netdev_register_kobject+0x139/0x1a0
 [<ffffffff8171f508>] register_netdevice+0x4d8/0x660
 [<ffffffff8171f6aa>] register_netdev+0x1a/0x30
 [<ffffffff81617d1a>] loopback_net_init+0x5a/0xd0
 [<ffffffff8170e64b>] ops_init+0x5b/0x1b0
 [<ffffffff8170e86b>] setup_net+0xcb/0x1f0
 [<ffffffff8170f1e8>] copy_net_ns+0x88/0x150
 [<ffffffff8111c537>] create_new_namespaces+0x1f7/0x2d0
 [<ffffffff8111c822>] unshare_nsproxy_namespaces+0x72/0xd0
 [<ffffffff810e10a1>] SyS_unshare+0x1c1/0x340
 [<ffffffff81842312>] system_call_fastpath+0x16/0x1b

The buggy address ffff8800230ef384 is located 68 bytes inside
 of 96-byte region [ffff8800230ef340, ffff8800230ef3a0)

Memory state around the buggy address:
 ffff8800230eee00: ........ ....rrrr rrrrrrrr rrrrrrrr
 ffff8800230eef00: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef000: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef100: rrrrrrrr rrrrrrrr ........ ....rrrr
 ffff8800230ef200: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
>ffff8800230ef300: rrrrrrrr ffffffff ffffrrrr rrrrrrrr
                                     ^
 ffff8800230ef400: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef500: ........ ....rrrr rrrrrrrr rrrrrrrr
 ffff8800230ef600: rrrrrrrr rrrrrrrr rrrrrrrr ........
 ffff8800230ef700: ....rrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef800: rrrrrrrr rrrrrrrr ........ ....rrrr
Legend:
 f - 8 freed bytes
 r - 8 redzone bytes
 . - 8 allocated bytes
 x=1..7 - x allocated bytes + (8-x) redzone bytes
=========================================================================

If your kernel was compiled with CONFIG_DEBUG_INFO=y you can use addr2line
to get file and line info of each frame of the stack.

XXX: explain how to use addr2line (kmemcheck.txt explains)?

This can be also done via our symbolizer script (see the ASAN web page).
The script also symbolizes stack frames which come from dynamic modules.
As a result the report will be much easier to investigate.

Here is the report after symbolization:

=========================================================================
AddressSanitizer: heap-use-after-free on address ffff8800230ef384
Write of size 4 by thread T12887:
 [<ffffffff811046dc>] ____call_usermodehelper+0x20c/0x230 ./kernel/kmod.c:250
 [<ffffffff81104733>] call_helper+0x33/0x40 ./kernel/kmod.c:258
 [<ffffffff8184226c>] ret_from_fork+0x7c/0xb0 ./arch/x86/kernel/entry_64.S:554

Freed by thread T12636:
 [<ffffffff8110424c>] call_usermodehelper_freeinfo+0x2c/0x30 ./kernel/kmod.c:265
 [<ffffffff811049d5>] call_usermodehelper_exec+0xa5/0x1c0 ./kernel/kmod.c:612
 [<ffffffff811052b0>] call_usermodehelper+0x40/0x60 ./kernel/kmod.c:642
 [<ffffffff8146c15e>] kobject_uevent_env+0x5ee/0x620 ./lib/kobject_uevent.c:311
 [<ffffffff8146c19b>] kobject_uevent+0xb/0x10 ./lib/kobject_uevent.c:333
 [<     inlined    >] net_rx_queue_update_kobjects+0xaf/0x150 rx_queue_add_kobject ./net/core/net-sysfs.c:771
 [<ffffffff8173bd7f>] net_rx_queue_update_kobjects+0xaf/0x150 ./net/core/net-sysfs.c:786
 [<     inlined    >] netdev_register_kobject+0x139/0x1a0 register_queue_kobjects ./net/core/net-sysfs.c:1165
 [<ffffffff8173c179>] netdev_register_kobject+0x139/0x1a0 ./net/core/net-sysfs.c:1336
 [<ffffffff8171f508>] register_netdevice+0x4d8/0x660 ./net/core/dev.c:5662
 [<ffffffff8171f6aa>] register_netdev+0x1a/0x30 ./net/core/dev.c:5774
 [<ffffffff81617d1a>] loopback_net_init+0x5a/0xd0 loopback.c:0
 [<ffffffff8170e64b>] ops_init+0x5b/0x1b0 ./net/core/net_namespace.c:106
 [<ffffffff8170e86b>] setup_net+0xcb/0x1f0 ./net/core/net_namespace.c:167
 [<ffffffff8170f1e8>] copy_net_ns+0x88/0x150 ./net/core/net_namespace.c:254
 [<ffffffff8111c537>] create_new_namespaces+0x1f7/0x2d0 ./kernel/nsproxy.c:95
 [<ffffffff8111c822>] unshare_nsproxy_namespaces+0x72/0xd0 ./kernel/nsproxy.c:190
 [<     inlined    >] SyS_unshare+0x1c1/0x340 SYSC_unshare ./kernel/fork.c:1853
 [<ffffffff810e10a1>] SyS_unshare+0x1c1/0x340 ./kernel/fork.c:1804

Allocated by thread T12636:
 [<     inlined    >] call_usermodehelper_setup+0x5b/0x170 kmalloc ./include/linux/slab.h:404
 [<     inlined    >] call_usermodehelper_setup+0x5b/0x170 kzalloc ./include/linux/slab.h:645
 [<ffffffff81104dfb>] call_usermodehelper_setup+0x5b/0x170 ./kernel/kmod.c:540
 [<ffffffff811052a1>] call_usermodehelper+0x31/0x60 ./kernel/kmod.c:637
 [<ffffffff8146c15e>] kobject_uevent_env+0x5ee/0x620 ./lib/kobject_uevent.c:311
 [<ffffffff8146c19b>] kobject_uevent+0xb/0x10 ./lib/kobject_uevent.c:333
 [<     inlined    >] net_rx_queue_update_kobjects+0xaf/0x150 rx_queue_add_kobject ./net/core/net-sysfs.c:771
 [<ffffffff8173bd7f>] net_rx_queue_update_kobjects+0xaf/0x150 ./net/core/net-sysfs.c:786
 [<     inlined    >] netdev_register_kobject+0x139/0x1a0 register_queue_kobjects ./net/core/net-sysfs.c:1165
 [<ffffffff8173c179>] netdev_register_kobject+0x139/0x1a0 ./net/core/net-sysfs.c:1336
 [<ffffffff8171f508>] register_netdevice+0x4d8/0x660 ./net/core/dev.c:5662
 [<ffffffff8171f6aa>] register_netdev+0x1a/0x30 ./net/core/dev.c:5774
 [<ffffffff81617d1a>] loopback_net_init+0x5a/0xd0 loopback.c:0
 [<ffffffff8170e64b>] ops_init+0x5b/0x1b0 ./net/core/net_namespace.c:106
 [<ffffffff8170e86b>] setup_net+0xcb/0x1f0 ./net/core/net_namespace.c:167
 [<ffffffff8170f1e8>] copy_net_ns+0x88/0x150 ./net/core/net_namespace.c:254
 [<ffffffff8111c537>] create_new_namespaces+0x1f7/0x2d0 ./kernel/nsproxy.c:95
 [<ffffffff8111c822>] unshare_nsproxy_namespaces+0x72/0xd0 ./kernel/nsproxy.c:190
 [<     inlined    >] SyS_unshare+0x1c1/0x340 SYSC_unshare ./kernel/fork.c:1853
 [<ffffffff810e10a1>] SyS_unshare+0x1c1/0x340 ./kernel/fork.c:1804
 [<ffffffff81842312>] system_call_fastpath+0x16/0x1b ./arch/x86/kernel/entry_64.S:629

The buggy address ffff8800230ef384 is located 68 bytes inside
 of 96-byte region [ffff8800230ef340, ffff8800230ef3a0)

Memory state around the buggy address:
 ffff8800230eee00: ........ ....rrrr rrrrrrrr rrrrrrrr
 ffff8800230eef00: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef000: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef100: rrrrrrrr rrrrrrrr ........ ....rrrr
 ffff8800230ef200: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
>ffff8800230ef300: rrrrrrrr ffffffff ffffrrrr rrrrrrrr
                                     ^
 ffff8800230ef400: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef500: ........ ....rrrr rrrrrrrr rrrrrrrr
 ffff8800230ef600: rrrrrrrr rrrrrrrr rrrrrrrr ........
 ffff8800230ef700: ....rrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef800: rrrrrrrr rrrrrrrr ........ ....rrrr
Legend:
 f - 8 freed bytes
 r - 8 redzone bytes
 . - 8 allocated bytes
 x=1..7 - x allocated bytes + (8-x) redzone bytes
=========================================================================

Let's take a closer look to different parts of the report.

The header tells us what kind of bug happend and where:

AddressSanitizer: heap-use-after-free on address ffff8800230ef384
Write of size 4 by thread T12887:
 [<ffffffff811046dc>] ____call_usermodehelper+0x20c/0x230 ./kernel/kmod.c:250
 [<ffffffff81104733>] call_helper+0x33/0x40 ./kernel/kmod.c:258
 [<ffffffff8184226c>] ret_from_fork+0x7c/0xb0 ./arch/x86/kernel/entry_64.S:554

Here we can see that 4 bytes were written to a freed memory region in function
____call_usermodehelper() which was called by thread T12887.

The address of the instruction that caused the bad access is also present, but
since the report was symbolized we can look at the file and line info instead.

By looking in kernel/kmod.c, line 250 we can see that the report was caused by
assigning some value to sub_info->retval.

202 static int ____call_usermodehelper(void *data)
203 {
...
248         /* Exec failed? */
249 fail:
250         sub_info->retval = retval;
251         do_exit(0);
252 }

Since this is a use-after-free bug the sub_info was apparently freed somewhere.
The report provides information about where it happened:

Freed by thread T12636:
 [<ffffffff8110424c>] call_usermodehelper_freeinfo+0x2c/0x30 ./kernel/kmod.c:265
 [<ffffffff811049d5>] call_usermodehelper_exec+0xa5/0x1c0 ./kernel/kmod.c:612
 [<ffffffff811052b0>] call_usermodehelper+0x40/0x60 ./kernel/kmod.c:642
 [<ffffffff8146c15e>] kobject_uevent_env+0x5ee/0x620 ./lib/kobject_uevent.c:311
 [<ffffffff8146c19b>] kobject_uevent+0xb/0x10 ./lib/kobject_uevent.c:333
 [<     inlined    >] net_rx_queue_update_kobjects+0xaf/0x150 rx_queue_add_kobject ./net/core/net-sysfs.c:771
 [<ffffffff8173bd7f>] net_rx_queue_update_kobjects+0xaf/0x150 ./net/core/net-sysfs.c:786
 [<     inlined    >] netdev_register_kobject+0x139/0x1a0 register_queue_kobjects ./net/core/net-sysfs.c:1165
 [<ffffffff8173c179>] netdev_register_kobject+0x139/0x1a0 ./net/core/net-sysfs.c:1336
 [<ffffffff8171f508>] register_netdevice+0x4d8/0x660 ./net/core/dev.c:5662
 [<ffffffff8171f6aa>] register_netdev+0x1a/0x30 ./net/core/dev.c:5774
 [<ffffffff81617d1a>] loopback_net_init+0x5a/0xd0 loopback.c:0
 [<ffffffff8170e64b>] ops_init+0x5b/0x1b0 ./net/core/net_namespace.c:106
 [<ffffffff8170e86b>] setup_net+0xcb/0x1f0 ./net/core/net_namespace.c:167
 [<ffffffff8170f1e8>] copy_net_ns+0x88/0x150 ./net/core/net_namespace.c:254
 [<ffffffff8111c537>] create_new_namespaces+0x1f7/0x2d0 ./kernel/nsproxy.c:95
 [<ffffffff8111c822>] unshare_nsproxy_namespaces+0x72/0xd0 ./kernel/nsproxy.c:190
 [<     inlined    >] SyS_unshare+0x1c1/0x340 SYSC_unshare ./kernel/fork.c:1853
 [<ffffffff810e10a1>] SyS_unshare+0x1c1/0x340 ./kernel/fork.c:1804

The report shows that sub_info was freed by call_usermodehelper_freeinfo()
in kernel/kmod.c, line 265:

261 static void call_usermodehelper_freeinfo(struct subprocess_info *info)
262 {
263         if (info->cleanup)
264                 (*info->cleanup)(info);
265         kfree(info);
266 }

You can see where the allocation happened as well:

Allocated by thread T12636:
 [<     inlined    >] call_usermodehelper_setup+0x5b/0x170 kmalloc ./include/linux/slab.h:404
 [<     inlined    >] call_usermodehelper_setup+0x5b/0x170 kzalloc ./include/linux/slab.h:645
 [<ffffffff81104dfb>] call_usermodehelper_setup+0x5b/0x170 ./kernel/kmod.c:540
 [<ffffffff811052a1>] call_usermodehelper+0x31/0x60 ./kernel/kmod.c:637
 [<ffffffff8146c15e>] kobject_uevent_env+0x5ee/0x620 ./lib/kobject_uevent.c:311
 [<ffffffff8146c19b>] kobject_uevent+0xb/0x10 ./lib/kobject_uevent.c:333
 [<     inlined    >] net_rx_queue_update_kobjects+0xaf/0x150 rx_queue_add_kobject ./net/core/net-sysfs.c:771
 [<ffffffff8173bd7f>] net_rx_queue_update_kobjects+0xaf/0x150 ./net/core/net-sysfs.c:786
 [<     inlined    >] netdev_register_kobject+0x139/0x1a0 register_queue_kobjects ./net/core/net-sysfs.c:1165
 [<ffffffff8173c179>] netdev_register_kobject+0x139/0x1a0 ./net/core/net-sysfs.c:1336
 [<ffffffff8171f508>] register_netdevice+0x4d8/0x660 ./net/core/dev.c:5662
 [<ffffffff8171f6aa>] register_netdev+0x1a/0x30 ./net/core/dev.c:5774
 [<ffffffff81617d1a>] loopback_net_init+0x5a/0xd0 loopback.c:0
 [<ffffffff8170e64b>] ops_init+0x5b/0x1b0 ./net/core/net_namespace.c:106
 [<ffffffff8170e86b>] setup_net+0xcb/0x1f0 ./net/core/net_namespace.c:167
 [<ffffffff8170f1e8>] copy_net_ns+0x88/0x150 ./net/core/net_namespace.c:254
 [<ffffffff8111c537>] create_new_namespaces+0x1f7/0x2d0 ./kernel/nsproxy.c:95
 [<ffffffff8111c822>] unshare_nsproxy_namespaces+0x72/0xd0 ./kernel/nsproxy.c:190
 [<     inlined    >] SyS_unshare+0x1c1/0x340 SYSC_unshare ./kernel/fork.c:1853
 [<ffffffff810e10a1>] SyS_unshare+0x1c1/0x340 ./kernel/fork.c:1804
 [<ffffffff81842312>] system_call_fastpath+0x16/0x1b ./arch/x86/kernel/entry_64.S:629

The first two frames of the allocation stack are the inlined calls of kmalloc
and kzalloc, which are defined in include/linux/slab.h. And the actual
allocation happened in kernel/kmod.c, line 540:

533 struct subprocess_info *call_usermodehelper_setup(char *path, char **argv,
534                 char **envp, gfp_t gfp_mask,
535                 int (*init)(struct subprocess_info *info, struct cred *new),
536                 void (*cleanup)(struct subprocess_info *info),
537                 void *data)
538 {
539         struct subprocess_info *sub_info;
540         sub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);
...
553         return sub_info;
554 }

Then, the report shows the address of the bad access and the memory range of
the allocated memory block to which it belongs:

The buggy address ffff8800230ef384 is located 68 bytes inside
 of 96-byte region [ffff8800230ef340, ffff8800230ef3a0)

Apparently, sizeof(struct subprocess_info) is 96 bytes and the retval field
is 68 bytes within the struct (you can find subprocess_info struct definition
in include/linux/kmod.h, line 56).

Finally, the report shows memory state around the accessed address:

Memory state around the buggy address:
 ffff8800230eee00: ........ ....rrrr rrrrrrrr rrrrrrrr
 ffff8800230eef00: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef000: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef100: rrrrrrrr rrrrrrrr ........ ....rrrr
 ffff8800230ef200: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
>ffff8800230ef300: rrrrrrrr ffffffff ffffrrrr rrrrrrrr
                                     ^
 ffff8800230ef400: rrrrrrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef500: ........ ....rrrr rrrrrrrr rrrrrrrr
 ffff8800230ef600: rrrrrrrr rrrrrrrr rrrrrrrr ........
 ffff8800230ef700: ....rrrr rrrrrrrr rrrrrrrr rrrrrrrr
 ffff8800230ef800: rrrrrrrr rrrrrrrr ........ ....rrrr
Legend:
 f - 8 freed bytes
 r - 8 redzone bytes
 . - 8 allocated bytes
 x=1..7 - x allocated bytes + (8-x) redzone bytes

Understanding this part of the report requires some more knowledge about how
ASAN works.

Each 8 bytes of memory can be marked as addressable, partially addressable,
freed or they can be part of a redzone.
If 8 bytes are marked as addressable that means that they belong to some
allocated memory block and it is possible to read or modify any of these
8 bytes. Addressable 8 bytes are indicated by '.' in the report.
When only the first N bytes out of 8 belong to an allocated memory block,
the 8 bytes are partially addressable. These 8 bytes are indicated by 'N'.
8 freed bytes are indicated by 'f' and 8 redzone bytes - by 'r'.

In the report above the arrows point to the letter 'f', which means that the
accessed address is marked as freed.

TODO: explain the bug.


2. Technical description
========================

From a high level, our approach to memory error detection is similar to that
of kmemcheck: use shadow memory to record whether each byte of memory is safe
to access, and use instrumentation to check the shadow memory on each memory
access. However, ASAN uses a more efficient shadow mapping, a more compact
shadow encoding and is faster than kmemcheck.

ASAN consists of two parts: an instrumentation module and a run-time library.
The instrumentation module modifies the code to check the address state for
each memory access. The current implementation is based on the GCC compiler.
The run-time library replaces kmem_cache_alloc, kmem_cache_free and related
functions, creates redzones around allocated memory regions, delays the reuse
of freed memory regions, and does error reporting.

XXX: better name than run-time library?

ASAN is tracking accesses only to the part of the kernel virtual address space,
which is directly mapped to the physical memory. That means that ASAN can't
detect bad accesses to the virtual memory allocated with vmalloc.

Currently, only SLAB allocator is supported by ASAN.


2.1. Shadow memory
==================

ASAN dedicates one-eighth of the main (physical) memory to its shadow memory.
Each shadow byte corresponds to 8 bytes of the main memory.

Poisoning or unpoisoning a byte in the main memory means writing some special
value into the corresponding shadow memory. This value indicates whether the
byte is addressable (valid to read or write) or not.

TODO: describe different shadow values.

2.2. Instrumentation
====================

ASAN requires the kernel to be built with a specific compiler. This compiler
adds memory address checking instructions before every memory access. These
instructions include checking if the accessed memory region is poisoned and
printing a report if yes.

TODO: what instructions are added by instrumentation.


2.3. Run-time library
=====================

The main purpose of the run-time library is to manage the shadow memory. At
kernel startup the entire shadow region is reserved so that no other part of
the kernel can use it.

The kmem_cache_alloc (kmalloc) and kmem_cache_free (kfree) functions are
replaced with a specialized implementation. The kmem_cache_alloc function
allocates extra memory, the redzone, around the returned region. The redzones
are marked as unaddressable, or poisoned. The larger the redzone, the larger
the overflows or underflows that will be detected.

The redzone is used to store some internal data (such as the allocation size,
thread ID, etc.). This internal data can not be corrupted by an out-of-bounds
write, because such writes are detected immediately prior to the actual store.

The kmem_cache_free function poisons the entire memory region and puts it into
quarantine, such that this region will not be allocated by kmem_cache_alloc any
time soon. Currently, the quarantine is implemented as a FIFO queue which holds
a fixed amount of memory at any time.

kmem_cache_alloc and kmem_cache_free record the current call stack in order to
provide more informative bug reports. The kmem_cache_alloc and kmem_cache_free
call stacks are stored in the redzone (the larger the redzone, the larger the
number of frames that can be stored).


3. Implementation details
=========================

3.1. Shadow memory
==================

TODO: shadow offset.
TODO: where and how allocated.
TODO: physical memory address range.
TODO: max_pfn.


3.2. Instrumentation
====================

TODO: gcc pass, functions naming format.


3.3. Run-time library
=====================

XXX: need to explain what are: cache, slab, object?

3.3.1. Redzones
===============

TODO: only right redzones.
TODO: redzone format.
TODO: 4mb cache issue.
TODO: redzone searching.

TODO: rewrite:

To detect out-of-bounds errors when an object is allocated some extra memory
is allocated around it. This extra memory is called redzone.

Each time a new slab cache is created the size of this cache (the size of the
objects that can be allocated from this cache) is increased so it is possible
to store some metainfo right after each object.
This metainfo includes allocation and deallocation stacks, identifiers of the
threads that allocated and deallocated the object, quarantine related info.


3.3.2. Poisoning / unpoisoning
==============================

TODO: poisoning function by function.
TODO: krealloc etc. problems

TODO: rewrite:

When a new slab is created the shadow memory for the pages allocated for
this slab is poisoned. This includes the slab header (in case it is on-slab),
the objects in this slab, the redzones around the objects.

Each time a new object is allocated from the cache the shadow memory for this
object is unpoisoned and allocation metainfo is stored in the redzone.

When a user tries to free an allocated object it's shadow memory is poisoned
and deallocation metainfo is stored in the redzone.

The objects allocated via kmalloc (or krealloc) are poisoned more accurately.
When a user asks for an N bytes object and the kmalloc cache of size K is used
for the allocation the object is allocated and unpoisoned as described above.
Then the last K - N bytes are poisoned again.


3.3.3. Quarantine
=================

TODO: linked list in the redzone.
TODO: quarantine is cleaned on slab creation.

TODO: rewrite:

When a user calls kmem_cache_free (or kfree) the object is poisoned, but not
deallocated right away, because otherwise it can be allocated again soon and
unpoisoned. Instead, the object is but put into a FIFO queue called quarantine.

The total size of the objects in quarantine is counted and some objects are
freed when the total size is more than some threshold.


3.3.4. Libc interception
========================

TODO: memset -> asam_memset etc.
